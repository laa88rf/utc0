<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Bubbles / Snow / Rain – Center Clock (Optimized)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #050816;
      font-family: system-ui, sans-serif;
      color: #ffffff;
    }

    canvas { display: block; }

    /* CLOCK */
    .clock {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 10;
      user-select: none;
      animation: clockFadeIn 0.9s ease-out forwards, clockBreath 5s ease-in-out infinite;
      opacity: 0;
      cursor: pointer;
    }

    .clock-time {
      font-family: "SF Mono", Consolas, monospace;
      font-weight: 600;
      font-size: clamp(36px, 9vw, 96px);
      letter-spacing: 0.08em;
      text-shadow:
        0 0 10px rgba(255,255,255,0.7),
        0 0 25px rgba(0,150,255,0.55);
      margin-bottom: 6px;
    }

    .clock-date {
      font-size: clamp(14px, 2.4vw, 18px);
      opacity: 0.9;
      letter-spacing: 0.04em;
      white-space: nowrap;
    }

    @keyframes clockFadeIn {
      0% { opacity: 0; transform: translate(-50%, -55%); }
      100% { opacity: 1; transform: translate(-50%, -50%); }
    }

    @keyframes clockBreath {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.02); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
  </style>
</head>
<body>

  <div class="clock" id="clock">
    <div class="clock-time" id="clockTime">00:00:00</div>
    <div class="clock-date" id="clockDate">Monday, January 01, 1970</div>
  </div>

  <canvas id="scene"></canvas>

  <script>
    /* ---------------- CONFIG / CONSTANTS ---------------- */

    const MODES = ["bubbles", "snow", "rain"];
    let modeIndex = 0;
    let mode = MODES[modeIndex];

    const MAX_PARTICLES = 450;
    const MAX_DPR = 1.5;

    // blur / fade
    let transitionAlpha = 0;
    let transitionStart = 0;
    const TRANSITION_DURATION = 350;
    const MAX_BLUR = 2; // было 4, теперь легче

    // scroll inertia
    let scrollAccum = 0;
    const SCROLL_THRESHOLD = 80;

    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d');

    const clockEl = document.getElementById('clock');
    const timeEl  = document.getElementById('clockTime');
    const dateEl  = document.getElementById('clockDate');

    let width = 0;
    let height = 0;
    let dpr = 1;

    let particles = [];

    /* ---------------- HELPERS ---------------- */

    const random = (a, b) => Math.random() * (b - a) + a;

    function resize() {
      const rectWidth = window.innerWidth;
      const rectHeight = window.innerHeight;

      dpr = Math.min(window.devicePixelRatio || 1, MAX_DPR);

      canvas.width  = rectWidth * dpr;
      canvas.height = rectHeight * dpr;
      canvas.style.width  = rectWidth + "px";
      canvas.style.height = rectHeight + "px";

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      width  = rectWidth;
      height = rectHeight;

      initParticles();
    }

    function setMode(newMode) {
      const idx = MODES.indexOf(newMode);
      if (idx === -1 || idx === modeIndex) return;
      modeIndex = idx;
      mode = MODES[modeIndex];
      startTransition();
    }

    function nextMode() {
      modeIndex = (modeIndex + 1) % MODES.length;
      mode = MODES[modeIndex];
      startTransition();
    }

    function prevMode() {
      modeIndex = (modeIndex - 1 + MODES.length) % MODES.length;
      mode = MODES[modeIndex];
      startTransition();
    }

    function startTransition() {
      initParticles();
      transitionAlpha = 1;
      transitionStart = performance.now();
    }

    /* ---------------- EVENTS ---------------- */

    window.addEventListener("wheel", e => {
      e.preventDefault();
      scrollAccum += e.deltaY;

      while (scrollAccum >= SCROLL_THRESHOLD) {
        prevMode();
        scrollAccum -= SCROLL_THRESHOLD;
      }
      while (scrollAccum <= -SCROLL_THRESHOLD) {
        nextMode();
        scrollAccum += SCROLL_THRESHOLD;
      }
    }, { passive: false });

    clockEl.addEventListener('click', nextMode);

    window.addEventListener('resize', resize);

    /* ---------------- PARTICLES INIT ---------------- */

    function initParticles() {
      particles = [];
      const isRain = mode === 'rain';
      const isSnow = mode === 'snow';

      // немного уменьшил плотность
      let density;
      if (isRain) density = 0.35;
      else if (isSnow) density = 0.22;
      else density = 0.14;

      let count = Math.floor(width * density);
      if (count > MAX_PARTICLES) count = MAX_PARTICLES;

      for (let i = 0; i < count; i++) {
        if (isRain) {
          particles.push({
            type: 'rain',
            x: random(0, width),
            y: random(0, height),
            length: random(10, 20),
            speedY: random(4, 9),
            opacity: random(0.15, 0.6),
          });
        } else if (isSnow) {
          particles.push({
            type: 'snow',
            x: random(0, width),
            y: random(0, height),
            radius: random(1.5, 3.5),
            speedY: random(0.5, 1.8),
            driftX: random(-0.4, 0.4),
            phase: random(0, Math.PI * 2),
            opacity: random(0.45, 0.9),
          });
        } else {
          particles.push({
            type: 'bubble',
            x: random(0, width),
            y: random(0, height),
            radius: random(6, 18),
            speedY: random(0.5, 1.8),
            driftX: random(-0.25, 0.25),
            phase: random(0, Math.PI * 2),
            opacity: random(0.35, 0.8),
            lineWidth: random(1, 1.8),
            hue: random(190, 260)
          });
        }
      }
    }

    /* ---------------- DRAWING ---------------- */

    function drawBackground() {
      ctx.fillStyle = '#050816';
      ctx.fillRect(0, 0, width, height);
    }

    function drawRain() {
      ctx.strokeStyle = 'rgba(173, 216, 230, 0.8)';
      ctx.lineWidth = 1;
      ctx.lineCap = 'round';

      for (let d of particles) {
        ctx.globalAlpha = d.opacity;

        ctx.beginPath();
        ctx.moveTo(d.x, d.y);
        ctx.lineTo(d.x, d.y + d.length);
        ctx.stroke();

        d.y += d.speedY;
        d.x += 0.4;

        if (d.y > height + d.length) {
          d.y = random(-50, 0);
          d.x = random(0, width);
        }
      }
      ctx.globalAlpha = 1;
    }

    function drawSnow() {
      ctx.fillStyle = '#ffffff';

      for (let f of particles) {
        ctx.globalAlpha = f.opacity;

        ctx.beginPath();
        ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
        ctx.fill();

        f.phase += 0.01;
        f.y += f.speedY;
        f.x += Math.sin(f.phase) * 0.4 + f.driftX;

        if (f.y > height + f.radius) {
          f.y = random(-50, -10);
          f.x = random(0, width);
        }
        if (f.x > width + 20) f.x = -20;
        if (f.x < -20)      f.x =  width + 20;
      }
      ctx.globalAlpha = 1;
    }

    function drawBubbles() {
      for (let b of particles) {
        ctx.globalAlpha = b.opacity;
        ctx.lineWidth = b.lineWidth;
        ctx.strokeStyle = `hsla(${b.hue}, 80%, 75%, ${b.opacity})`;

        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
        ctx.stroke();

        // highlight arc
        ctx.save();
        ctx.globalAlpha = b.opacity * 0.9;
        ctx.lineWidth = b.lineWidth * 0.85;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
        const r = b.radius * 0.9;
        ctx.beginPath();
        ctx.arc(b.x, b.y, r, -Math.PI * 0.15, -Math.PI * 0.7, true);
        ctx.stroke();
        ctx.restore();

        ctx.globalAlpha = 1;

        b.phase += 0.01;
        b.y -= b.speedY;
        b.x += Math.sin(b.phase) * 0.4 + b.driftX;

        b.hue += 0.02;
        if (b.hue > 260) b.hue = 190;

        if (b.y < -b.radius) {
          b.y = height + b.radius + random(0, 80);
          b.x = random(0, width);
        }
        if (b.x > width + 30) b.x = -30;
        if (b.x < -30)       b.x =  width + 30;
      }
    }

    /* ---------------- CLOCK ---------------- */

    const WEEKDAYS = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
    const MONTHS   = ["January","February","March","April","May","June",
                      "July","August","September","October","November","December"];

    function updateClock() {
      const n = new Date();
      timeEl.textContent =
        `${String(n.getUTCHours()).padStart(2,'0')}:`+
        `${String(n.getUTCMinutes()).padStart(2,'0')}:`+
        `${String(n.getUTCSeconds()).padStart(2,'0')}`;

      dateEl.textContent =
        `${WEEKDAYS[n.getUTCDay()]}, `+
        `${MONTHS[n.getUTCMonth()]} `+
        `${String(n.getUTCDate()).padStart(2,'0')}, `+
        `${n.getUTCFullYear()}`;
    }

    /* ---------------- ANIMATION LOOP ---------------- */

    function animate(ts) {
      drawBackground();

      if (mode === "rain") drawRain();
      else if (mode === "snow") drawSnow();
      else drawBubbles();

      // fade+blur
      let blur = 0;
      if (transitionAlpha > 0) {
        const t = Math.min(1, (ts - transitionStart) / TRANSITION_DURATION);
        transitionAlpha = 1 - t;

        const overlayAlpha = 0.45 * transitionAlpha; // было 0.6
        blur = MAX_BLUR * transitionAlpha;

        if (overlayAlpha > 0) {
          ctx.fillStyle = `rgba(5, 8, 22, ${overlayAlpha})`;
          ctx.fillRect(0, 0, width, height);
        }
      }

      canvas.style.filter = blur > 0.01 ? `blur(${blur.toFixed(2)}px)` : 'none';

      updateClock();
      requestAnimationFrame(animate);
    }

    /* ---------------- START ---------------- */

    resize();
    requestAnimationFrame(animate);
  </script>
</body>
</html>
