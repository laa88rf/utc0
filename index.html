<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />

  <!-- Primary Meta -->
  <title>Exact UTC+0 (GMT) Time Online — UTC0.ru</title>
  <meta name="title" content="Exact UTC+0 (GMT) Time Online — UTC0.ru" />
  <meta name="description"
        content="Real-time UTC+0 (GMT) online clock. Accurate world time based on Coordinated Universal Time." />
  <meta name="keywords"
        content="UTC, GMT, time, exact time, utc+0, world time, atomic time, universal time, online clock, utc0.ru" />

  <!-- Viewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Canonical -->
  <link rel="canonical" href="https://utc0.ru/" />

  <!-- Open Graph -->
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Exact UTC+0 (GMT) Time Online — UTC0.ru" />
  <meta property="og:description"
        content="Real-time UTC+0 (GMT) online clock. Accurate world time based on Coordinated Universal Time." />
  <meta property="og:url" content="https://utc0.ru/" />
  <meta property="og:site_name" content="UTC0.ru" />
  <meta property="og:image" content="https://utc0.ru/img/preview.png" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Exact UTC+0 (GMT) Time Online — UTC0.ru" />
  <meta name="twitter:description"
        content="Real-time UTC+0 (GMT) online clock. Accurate world time based on Coordinated Universal Time." />
  <meta name="twitter:image" content="https://utc0.ru/img/preview.png" />

  <!-- Robots -->
  <meta name="robots" content="index, follow" />

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="/favicon.png" />
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />

  <!-- Theme color -->
  <meta name="theme-color" content="#050816" />

  <!-- Structured Data (JSON-LD) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "name": "UTC0.ru",
    "url": "https://utc0.ru/",
    "description": "Real-time UTC+0 (GMT) online clock. Accurate world time.",
    "publisher": {
      "@type": "Organization",
      "name": "UTC0.ru"
    },
    "image": {
      "@type": "ImageObject",
      "url": "https://utc0.ru/img/preview.png",
      "width": 1200,
      "height": 630
    }
  }
  </script>

  <!-- Styles -->
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #050816;
      font-family: system-ui, sans-serif;
      color: #ffffff;
    }

    canvas { display: block; }

    /* CLOCK */
    .clock {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 10;
      user-select: none;
      animation: clockFadeIn 0.9s ease-out forwards, clockBreath 5s ease-in-out infinite;
      opacity: 0;
      cursor: pointer;
    }

    .clock-time {
      font-family: "SF Mono", Consolas, monospace;
      font-weight: 600;
      font-size: clamp(36px, 9vw, 96px);
      letter-spacing: 0.08em;
      text-shadow:
        0 0 10px rgba(200,255,255,0.8),
        0 0 25px rgba(0,220,190,0.7);
      margin-bottom: 6px;
    }

    .clock-date {
      font-size: clamp(14px, 2.4vw, 18px);
      opacity: 0.9;
      letter-spacing: 0.04em;
      white-space: nowrap;
    }

    @keyframes clockFadeIn {
      0% { opacity: 0; transform: translate(-50%, -55%); }
      100% { opacity: 1; transform: translate(-50%, -50%); }
    }

    @keyframes clockBreath {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.02); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }

    /* Debug overlay */
    .debug-overlay {
      position: fixed;
      left: 10px;
      bottom: 8px;
      font-size: 11px;
      font-family: "SF Mono", Consolas, monospace;
      opacity: 0.55;
      z-index: 20;
      pointer-events: none;
      white-space: nowrap;
    }
  </style>
</head>

<body>

  <div class="clock" id="clock">
    <div class="clock-time" id="clockTime">00:00:00</div>
    <div class="clock-date" id="clockDate">Monday, January 01, 1970</div>
  </div>

  <canvas id="scene"></canvas>
  <div class="debug-overlay" id="debugOverlay"></div>

  <script>
    /* ---------------- EFFECTS & THEMES ---------------- */

    const EFFECTS = [
      "bubbles",
      "snow",
      "rain",
      "sparks",
      "dust",
      "stars"
    ];

    const THEMES  = ["aurora", "cyberpunk", "forest", "space", "sumi"];

    let effectIndex = 0;
    let themeIndex  = 0;

    let effect = EFFECTS[effectIndex];
    let theme  = THEMES[themeIndex];

    const THEME_CONFIGS = {
      aurora: {
        bgTop:    "#050816",
        bgMid1:   "#081a2b",
        bgMid2:   "#041f28",
        bgBottom: "#031619",
        overlayStops: [
          "rgba(19,255,223,0)",
          "rgba(19,255,223,0.09)",
          "rgba(126,255,107,0.12)",
          "rgba(194,85,255,0.09)",
          "rgba(19,255,223,0)"
        ],
        rainColor: "rgba(160, 230, 255, 0.9)",
        snowColor: "#e5f7ff",
        bubbleHueMin: 130,
        bubbleHueMax: 190,
        bubbleSat: 80,
        bubbleLight: 70,
        sparkHueMin: 160,
        sparkHueMax: 220,
        sparkSat: 90,
        sparkLight: 80
      },
      cyberpunk: {
        bgTop:    "#05010a",
        bgMid1:   "#12001f",
        bgMid2:   "#200038",
        bgBottom: "#080214",
        overlayStops: [
          "rgba(255,0,140,0)",
          "rgba(255,0,140,0.14)",
          "rgba(42,0,255,0.18)",
          "rgba(0,213,255,0.14)",
          "rgba(255,0,140,0)"
        ],
        rainColor: "rgba(0,255,255,0.9)",
        snowColor: "#f5e8ff",
        bubbleHueMin: 280,
        bubbleHueMax: 320,
        bubbleSat: 90,
        bubbleLight: 65,
        sparkHueMin: 190,
        sparkHueMax: 220,
        sparkSat: 95,
        sparkLight: 75
      },
      forest: {
        bgTop:    "#040b06",
        bgMid1:   "#071810",
        bgMid2:   "#0f2b1b",
        bgBottom: "#050c06",
        overlayStops: [
          "rgba(100,200,140,0)",
          "rgba(100,200,140,0.10)",
          "rgba(180,230,190,0.14)",
          "rgba(150,210,160,0.10)",
          "rgba(100,200,140,0)"
        ],
        rainColor: "rgba(180,230,200,0.85)",
        snowColor: "#e7f5ea",
        bubbleHueMin: 110,
        bubbleHueMax: 150,
        bubbleSat: 70,
        bubbleLight: 70,
        sparkHueMin: 90,
        sparkHueMax: 140,
        sparkSat: 80,
        sparkLight: 70
      },
      space: {
        bgTop:    "#000009",
        bgMid1:   "#050517",
        bgMid2:   "#0b0a26",
        bgBottom: "#050413",
        overlayStops: [
          "rgba(80,160,255,0)",
          "rgba(80,160,255,0.10)",
          "rgba(180,120,255,0.14)",
          "rgba(120,200,255,0.10)",
          "rgba(80,160,255,0)"
        ],
        rainColor: "rgba(160,200,255,0.9)",
        snowColor: "#f0f4ff",
        bubbleHueMin: 200,
        bubbleHueMax: 260,
        bubbleSat: 80,
        bubbleLight: 70,
        sparkHueMin: 190,
        sparkHueMax: 260,
        sparkSat: 90,
        sparkLight: 80
      },
      sumi: {
        bgTop:    "#050505",
        bgMid1:   "#101010",
        bgMid2:   "#181818",
        bgBottom: "#050505",
        overlayStops: [
          "rgba(255,255,255,0)",
          "rgba(255,255,255,0.04)",
          "rgba(255,255,255,0.06)",
          "rgba(255,255,255,0.04)",
          "rgba(255,255,255,0)"
        ],
        rainColor: "rgba(200,200,200,0.7)",
        snowColor: "#f5f5f5",
        bubbleHueMin: 0,
        bubbleHueMax: 0,
        bubbleSat: 0,
        bubbleLight: 80,
        sparkHueMin: 0,
        sparkHueMax: 0,
        sparkSat: 0,
        sparkLight: 90
      }
    };

    let themeConfig = THEME_CONFIGS[theme];

    /* ---------------- RENDER CONFIG ---------------- */

    const MAX_PARTICLES = 500;
    const MAX_DPR = 1.5;

    let transitionAlpha = 0;
    let transitionStart = 0;
    const TRANSITION_DURATION = 350;
    const MAX_BLUR = 2;

    let scrollAccum = 0;
    const SCROLL_THRESHOLD = 80;

    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d');

    const clockEl = document.getElementById('clock');
    const timeEl  = document.getElementById('clockTime');
    const dateEl  = document.getElementById('clockDate');
    const debugEl = document.getElementById('debugOverlay');

    let width = 0, height = 0, dpr = 1;
    let particles = [];

    // Debug overlay visibility + long press
    let debugVisible = false;  // по умолчанию скрыт
    let pressTimer = null;
    let longPressFired = false;
    const LONG_PRESS_MS = 600;

    /* ---------------- HELPERS ---------------- */
    const random = (a, b) => Math.random() * (b - a) + a;

    function renderDebugOverlay() {
      if (!debugEl) return;
      if (!debugVisible) {
        debugEl.style.display = 'none';
        return;
      }
      debugEl.style.display = 'block';
      debugEl.textContent = `${effect} • ${theme}`;
    }

    function toggleDebugOverlay() {
      debugVisible = !debugVisible;
      renderDebugOverlay();
    }

    function applyThemeAndEffect(stepDir) {
      if (stepDir > 0) {
        effectIndex = (effectIndex + 1) % EFFECTS.length;
        themeIndex  = (themeIndex + 1)  % THEMES.length;
      } else {
        effectIndex = (effectIndex - 1 + EFFECTS.length) % EFFECTS.length;
        themeIndex  = (themeIndex - 1 + THEMES.length)  % THEMES.length;
      }
      effect = EFFECTS[effectIndex];
      theme  = THEMES[themeIndex];
      themeConfig = THEME_CONFIGS[theme];
      renderDebugOverlay();
      startTransition();
    }

    function resize() {
      const rectWidth = window.innerWidth;
      const rectHeight = window.innerHeight;

      dpr = Math.min(window.devicePixelRatio || 1, MAX_DPR);

      canvas.width  = rectWidth * dpr;
      canvas.height = rectHeight * dpr;
      canvas.style.width  = rectWidth + "px";
      canvas.style.height = rectHeight + "px";

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      width  = rectWidth;
      height = rectHeight;

      initParticles();
    }

    function startTransition() {
      initParticles();
      transitionAlpha = 1;
      transitionStart = performance.now();
    }

    /* ---------------- EVENTS ---------------- */

    window.addEventListener("wheel", e => {
      e.preventDefault();
      scrollAccum += e.deltaY;

      while (scrollAccum >= SCROLL_THRESHOLD) {
        applyThemeAndEffect(-1);
        scrollAccum -= SCROLL_THRESHOLD;
      }
      while (scrollAccum <= -SCROLL_THRESHOLD) {
        applyThemeAndEffect(1);
        scrollAccum += SCROLL_THRESHOLD;
      }
    }, { passive: false });

    // Клавиша D — показать/скрыть overlay
    window.addEventListener('keydown', (e) => {
      if (e.key === 'd' || e.key === 'D') {
        toggleDebugOverlay();
      }
    });

    // Long press на часах
    function startPress() {
      if (pressTimer) clearTimeout(pressTimer);
      longPressFired = false;
      pressTimer = setTimeout(() => {
        longPressFired = true;
        toggleDebugOverlay();
        pressTimer = null;
      }, LONG_PRESS_MS);
    }

    function cancelPress() {
      if (pressTimer) {
        clearTimeout(pressTimer);
        pressTimer = null;
      }
    }

    clockEl.addEventListener('mousedown', startPress);
    clockEl.addEventListener('touchstart', startPress, { passive: true });

    clockEl.addEventListener('mouseup', cancelPress);
    clockEl.addEventListener('mouseleave', cancelPress);
    clockEl.addEventListener('touchend', cancelPress);
    clockEl.addEventListener('touchcancel', cancelPress);

    // Клик по часам: если не было long press — переключаем эффект/тему
    clockEl.addEventListener('click', () => {
      if (longPressFired) {
        longPressFired = false;
        return;
      }
      applyThemeAndEffect(1);
    });

    window.addEventListener('resize', resize);

    /* ---------------- PARTICLES INIT ---------------- */

    function initParticles() {
      particles = [];

      const isRain   = effect === 'rain';
      const isSnow   = effect === 'snow';
      const isSparks = effect === 'sparks';
      const isDust   = effect === 'dust';
      const isStars  = effect === 'stars';

      let density;
      if (isRain)        density = 0.35;
      else if (isSnow)   density = 0.22;
      else if (isSparks) density = 0.25;
      else if (isDust)   density = 0.10;
      else if (isStars)  density = 0.12;
      else               density = 0.14;   // bubbles

      let count = Math.floor(width * density);
      if (count > MAX_PARTICLES) count = MAX_PARTICLES;

      for (let i = 0; i < count; i++) {
        if (isRain) {
          particles.push({
            type: 'rain',
            x: random(0, width),
            y: random(0, height),
            length: random(10, 20),
            speedY: random(4, 9),
            opacity: random(0.2, 0.7),
          });
        } else if (isSnow) {
          particles.push({
            type: 'snow',
            x: random(0, width),
            y: random(0, height),
            radius: random(1.5, 3.5),
            speedY: random(0.5, 1.8),
            driftX: random(-0.4, 0.4),
            phase: random(0, Math.PI * 2),
            opacity: random(0.5, 0.9),
          });
        } else if (isSparks) {
          const life = random(60, 200);
          particles.push({
            type: 'spark',
            x: random(0, width),
            y: random(0, height),
            radius: random(1.2, 2.4),
            speedX: random(-0.6, 0.6),
            speedY: random(-0.6, 0.2),
            baseOpacity: random(0.4, 1),
            life,
            maxLife: life,
            hue: random(themeConfig.sparkHueMin, themeConfig.sparkHueMax),
          });
        } else if (isDust) {
          particles.push({
            type: 'dust',
            x: random(0, width),
            y: random(0, height),
            radius: random(0.8, 1.8),
            speedX: random(-0.05, 0.05),
            speedY: random(-0.02, 0.02),
            phase: random(0, Math.PI * 2),
            opacity: random(0.1, 0.3)
          });
        } else if (isStars) {
          particles.push({
            type: 'star',
            x: random(0, width),
            y: random(0, height),
            radius: random(0.8, 1.8),
            twinklePhase: random(0, Math.PI * 2),
            depth: random(0.3, 1),
          });
        } else {
          // bubbles
          particles.push({
            type: 'bubble',
            x: random(0, width),
            y: random(0, height),
            radius: random(6, 18),
            speedY: random(0.5, 1.8),
            driftX: random(-0.25, 0.25),
            phase: random(0, Math.PI * 2),
            opacity: random(0.35, 0.85),
            lineWidth: random(1, 1.8),
            hue: random(themeConfig.bubbleHueMin, themeConfig.bubbleHueMax)
          });
        }
      }
    }

    /* ---------------- BACKGROUND ---------------- */

    function drawBackground() {
      const t = themeConfig;

      const grad = ctx.createLinearGradient(0, 0, 0, height);
      grad.addColorStop(0,    t.bgTop);
      grad.addColorStop(0.35, t.bgMid1);
      grad.addColorStop(0.7,  t.bgMid2);
      grad.addColorStop(1,    t.bgBottom);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, width, height);

      const overlayWidth = width * 0.5;
      const overlayX = (width - overlayWidth) / 2;
      const og = ctx.createLinearGradient(overlayX, 0, overlayX + overlayWidth, 0);

      og.addColorStop(0,   t.overlayStops[0]);
      og.addColorStop(0.2, t.overlayStops[1]);
      og.addColorStop(0.5, t.overlayStops[2]);
      og.addColorStop(0.8, t.overlayStops[3]);
      og.addColorStop(1,   t.overlayStops[4]);

      ctx.fillStyle = og;
      ctx.fillRect(0, 0, width, height);
    }

    /* ---------------- EFFECT DRAWING ---------------- */

    function drawRain() {
      ctx.strokeStyle = themeConfig.rainColor;
      ctx.lineWidth = 1;
      ctx.lineCap = 'round';

      for (let d of particles) {
        ctx.globalAlpha = d.opacity;
        ctx.beginPath();
        ctx.moveTo(d.x, d.y);
        ctx.lineTo(d.x, d.y + d.length);
        ctx.stroke();

        d.y += d.speedY;
        d.x += 0.35;

        if (d.y > height + d.length) {
          d.y = random(-50, 0);
          d.x = random(0, width);
        }
      }
      ctx.globalAlpha = 1;
    }

    function drawSnow() {
      ctx.fillStyle = themeConfig.snowColor;

      for (let f of particles) {
        ctx.globalAlpha = f.opacity;

        ctx.beginPath();
        ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
        ctx.fill();

        f.phase += 0.01;
        f.y += f.speedY;
        f.x += Math.sin(f.phase) * 0.4 + f.driftX;

        if (f.y > height + f.radius) {
          f.y = random(-50, -10);
          f.x = random(0, width);
        }
        if (f.x > width + 20) f.x = -20;
        if (f.x < -20)      f.x =  width + 20;
      }
      ctx.globalAlpha = 1;
    }

    function drawBubbles() {
      const t = themeConfig;

      for (let b of particles) {
        ctx.globalAlpha = b.opacity;
        ctx.lineWidth = b.lineWidth;
        ctx.strokeStyle = `hsla(${b.hue}, ${t.bubbleSat}%, ${t.bubbleLight}%, ${b.opacity})`;

        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
        ctx.stroke();

        // highlight
        ctx.save();
        ctx.globalAlpha = b.opacity * 0.95;
        ctx.lineWidth = b.lineWidth * 0.85;
        ctx.strokeStyle = 'rgba(230,255,255,0.95)';
        const r = b.radius * 0.92;
        ctx.beginPath();
        ctx.arc(b.x, b.y, r, -Math.PI * 0.1, -Math.PI * 0.75, true);
        ctx.stroke();
        ctx.restore();

        ctx.globalAlpha = 1;

        b.phase += 0.01;
        b.y -= b.speedY;
        b.x += Math.sin(b.phase) * 0.4 + b.driftX;

        b.hue += 0.03;
        if (b.hue > t.bubbleHueMax) b.hue = t.bubbleHueMin;

        if (b.y < -b.radius) {
          b.y = height + b.radius + random(0, 80);
          b.x = random(0, width);
        }
        if (b.x > width + 30) b.x = -30;
        if (b.x < -30)       b.x =  width + 30;
      }
    }

    function drawSparks() {
      const t = themeConfig;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';

      for (let s of particles) {
        const lifeRatio = s.life / s.maxLife;
        const opacity = s.baseOpacity * lifeRatio;
        const r = s.radius;

        const grad = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, r);
        grad.addColorStop(0, `hsla(${s.hue}, ${t.sparkSat}%, ${t.sparkLight}%, ${opacity})`);
        grad.addColorStop(0.5, `hsla(${s.hue}, ${t.sparkSat}%, ${t.sparkLight - 20}%, ${opacity * 0.8})`);
        grad.addColorStop(1, `hsla(${s.hue}, ${t.sparkSat}%, ${t.sparkLight - 30}%, 0)`);

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
        ctx.fill();

        s.x += s.speedX;
        s.y += s.speedY + 0.03;

        s.hue += 0.2;
        if (s.hue > t.sparkHueMax) s.hue = t.sparkHueMin;

        s.life -= 1;
        if (s.life <= 0 || s.x < -20 || s.x > width + 20 || s.y > height + 20) {
          const life = random(60, 200);
          s.x = random(0, width);
          s.y = random(0, height);
          s.radius = random(1.2, 2.4);
          s.speedX = random(-0.6, 0.6);
          s.speedY = random(-0.6, 0.2);
          s.baseOpacity = random(0.4, 1);
          s.life = life;
          s.maxLife = life;
          s.hue = random(t.sparkHueMin, t.sparkHueMax);
        }
      }

      ctx.restore();
      ctx.globalAlpha = 1;
    }

    function drawDust() {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = 'rgba(255,255,255,0.12)';

      for (let d of particles) {
        const alpha = d.opacity * (0.5 + 0.5 * Math.sin(d.phase));
        ctx.globalAlpha = alpha;

        ctx.beginPath();
        ctx.arc(d.x, d.y, d.radius, 0, Math.PI * 2);
        ctx.fill();

        d.x += d.speedX;
        d.y += d.speedY;
        d.phase += 0.002;

        if (d.x < -30) d.x = width + 30;
        if (d.x > width + 30) d.x = -30;
        if (d.y < -30) d.y = height + 30;
        if (d.y > height + 30) d.y = -30;
      }

      ctx.restore();
      ctx.globalAlpha = 1;
    }

    function drawStars() {
      ctx.save();
      ctx.fillStyle = '#ffffff';

      for (let s of particles) {
        s.twinklePhase += 0.01;
        const twinkle = (Math.sin(s.twinklePhase * 3) + 1) / 2;
        const alpha = 0.2 + twinkle * 0.8;
        ctx.globalAlpha = alpha;

        ctx.beginPath();
        ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
        ctx.fill();

        s.y += 0.02 + (1 - s.depth) * 0.05;

        if (s.y > height + 10) {
          s.y = -10;
          s.x = random(0, width);
        }
      }

      ctx.restore();
      ctx.globalAlpha = 1;
    }

    /* ---------------- CLOCK ---------------- */

    const WEEKDAYS = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
    const MONTHS   = ["January","February","March","April","May","June","July",
                      "August","September","October","November","December"];

    function updateClock() {
      const n = new Date();
      timeEl.textContent =
        `${String(n.getUTCHours()).padStart(2,'0')}:`+
        `${String(n.getUTCMinutes()).padStart(2,'0')}:`+
        `${String(n.getUTCSeconds()).padStart(2,'0')}`;

      dateEl.textContent =
        `${WEEKDAYS[n.getUTCDay()]}, `+
        `${MONTHS[n.getUTCMonth()]} `+
        `${String(n.getUTCDate()).padStart(2,'0')}, `+
        `${n.getUTCFullYear()}`;
    }

    /* ---------------- ANIMATE ---------------- */

    function animate(ts) {
      drawBackground();

      if (effect === "rain")         drawRain();
      else if (effect === "snow")    drawSnow();
      else if (effect === "bubbles") drawBubbles();
      else if (effect === "sparks")  drawSparks();
      else if (effect === "dust")    drawDust();
      else if (effect === "stars")   drawStars();

      let blur = 0;
      if (transitionAlpha > 0) {
        const t = Math.min(1, (ts - transitionStart) / TRANSITION_DURATION);
        transitionAlpha = 1 - t;

        const overlayAlpha = 0.4 * transitionAlpha;
        blur = MAX_BLUR * transitionAlpha;

        if (overlayAlpha > 0) {
          ctx.fillStyle = `rgba(3, 10, 20, ${overlayAlpha})`;
          ctx.fillRect(0, 0, width, height);
        }
      }

      canvas.style.filter = blur > 0.01 ? `blur(${blur.toFixed(2)}px)` : 'none';

      updateClock();
      requestAnimationFrame(animate);
    }

    /* ---------------- START ---------------- */

    resize();
    renderDebugOverlay();   // отрисует как скрытый
    requestAnimationFrame(animate);

  </script>
</body>
</html>
